"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFlexChangeToConfigTableColumn = addFlexChangeToConfigTableColumn;
exports.addFlexChangeToConfigTable = addFlexChangeToConfigTable;
exports.importFlexChangesOfColumn = importFlexChangesOfColumn;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const common_1 = require("../../../common");
/**
 * Checks whether a given flex change applies to a given table column. If this is the case the change is filled into the config.
 * @param {ConfigTableType} config - the table configuration
 * @param {FlexForTransfer} change - the flex change
 * @param {string} columnKey - the column key. If the column key is not equal to the column id of the change, the change will not be added to the column.
 * @param {object} customColumn - the custom column. If set, the property of the change will be added to the given column.
 */
function addFlexChangeToConfigTableColumn(config, change, columnKey, customColumn) {
    if (change.controlType === ux_specification_types_1.ControlType.TableColumn || change.controlType === ux_specification_types_1.ControlType.Button) {
        const idParts = change.controlId.split('-');
        const lastIdPart = idParts[idParts.length - 1];
        // As the last stable Id part is still too long in some cases, strip off the fixed parts.
        // It must the be added again by the export!
        const annotationPart = change.controlType === ux_specification_types_1.ControlType.TableColumn
            ? lastIdPart.split('template:::TableColumn:::')
            : [lastIdPart];
        const colId = customColumn
            ? annotationPart[annotationPart.length - 1]
            : annotationPart[annotationPart.length - 1]
                .replace(/sSmartTableId.+?:::/, '')
                .replace('::com.sap.vocabularies', ux_specification_types_1.VOCWITHCOLONS);
        let columnKeyEncoded = columnKey?.replace(/@/g, ':40').replace(/#/g, ':23');
        if (columnKeyEncoded?.startsWith('DataField')) {
            //Regular encoding of stable ID's
            columnKeyEncoded = columnKeyEncoded?.replace('/', ':2f');
        }
        else {
            //legacy encoding, for smart table columns only
            columnKeyEncoded = columnKeyEncoded?.replace('/', '_');
        }
        //Compare column part of the selectorId with the given columnKey
        if (columnKeyEncoded !== colId && columnKey !== colId) {
            return;
        }
        //Add property of flex change to the column in config
        if (customColumn) {
            customColumn[change.propertyId] = change.newValue;
        }
        else {
            if (!config.columns) {
                config.columns = {};
            }
            if (!config.columns[columnKey]) {
                config.columns[columnKey] = {};
            }
            config.columns[columnKey][change.propertyId] = change.newValue;
        }
    }
}
/**
 * Fills a table column flex change into the config, if it is relevant for the table
 * @param {ConfigTableType} config - the table configuration
 * @param {FlexForTransfer} change - the flex change
 */
function addFlexChangeToConfigTable(config, change, lineItemsDefinition) {
    if (change.controlType?.endsWith(ux_specification_types_1.DefinitionName.Table) &&
        Object.keys(lineItemsDefinition.properties).indexOf(change.propertyId) > -1) {
        config[change.propertyId] = change.newValue;
    }
}
/**
 * Imports the flex changes for a table column
 * @param {CommonImportParameters} importParameters - common import parameters
 * @param {v2.ListReportConfigV} listReportConfig - the list report configuration
 * @param {string} columnKey - the column key
 * @param {object} customColumn - optional: the custom column
 * @param {string} lineItemsId - the line items id
 */
function importFlexChangesOfColumn(importParameters, listReportConfig, columnKey, customColumn, lineItemsId = 'LineItems') {
    //Check all flex changes against the given column key
    importParameters.flex.forEach((changeString) => {
        const change = (0, common_1.parseChangeString)(changeString);
        const flexForTransfer = {
            controlId: change.controlId,
            propertyId: change.content?.property,
            newValue: change.content?.newBinding ? change.content.newBinding : change.content?.newValue,
            controlType: change.controlType,
            creation: change.creation
        };
        let schemaProperty;
        //The relevant schema property can either reside on column or table level
        if (change.controlType === ux_specification_types_1.ControlType.TableColumn) {
            schemaProperty =
                importParameters.jsonSchema['definitions'][`TableColumn`].properties[flexForTransfer.propertyId];
        }
        else {
            //Determine the right table type ID for the schema entry
            const tableTypeId = (!listReportConfig.table.type || listReportConfig.table.type === ux_specification_types_1.v2.TableTypeV2.ResponsiveTable) &&
                !flexForTransfer.controlId?.includes(ux_specification_types_1.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP.get(ux_specification_types_1.PageTypeV2.AnalyticalListPage))
                ? 'ResponsiveTableWithMultiSelect'
                : listReportConfig.table.constructor.name;
            schemaProperty =
                importParameters.jsonSchema['definitions'][`${tableTypeId}<${lineItemsId}>`]?.properties[flexForTransfer.propertyId];
        }
        if (schemaProperty) {
            //Add the flex change to the config
            addFlexChangeToConfigTableColumn(listReportConfig.table, flexForTransfer, columnKey, customColumn);
        }
    });
}
//# sourceMappingURL=table.js.map