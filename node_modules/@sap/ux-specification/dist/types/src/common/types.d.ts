import type { EntityType } from '@sap-ux/vocabularies-types';
import type { Definition } from 'typescript-json-schema';
import type { Manifest } from './webapp/manifest';
import type { GenerateAppSchemaParameters } from '../apiTypes';
export declare enum FlexibleColumnLayoutType {
    OneColumn = "OneColumn",
    TwoColumnsBeginExpanded = "TwoColumnsBeginExpanded",
    TwoColumnsMidExpanded = "TwoColumnsMidExpanded",
    MidColumnFullScreen = "MidColumnFullScreen",
    ThreeColumnsMidExpanded = "ThreeColumnsMidExpanded",
    ThreeColumnsEndExpanded = "ThreeColumnsEndExpanded",
    ThreeColumnsMidExpandedEndHidden = "ThreeColumnsMidExpandedEndHidden",
    ThreeColumnsBeginExpandedEndHidden = "ThreeColumnsBeginExpandedEndHidden",
    EndColumnFullScreen = "EndColumnFullScreen"
}
export declare const enum FlexChangeLayer {
    Vendor = "VENDOR",
    Customer = "CUSTOMER_BASE"
}
export type ManifestSettingsType = boolean | number | string | object;
/**
 * Type for all available schema types, e.g. Application, ListReport, ObjectPage, ...
 */
export declare enum SchemaType {
    Application = "Application",
    ObjectPage = "ObjectPage",
    ListReport = "ListReport",
    OverviewPage = "OverviewPage",
    AnalyticalListPage = "AnalyticalListPage",
    FreestylePage = "FreestylePage",
    FPMCustomPage = "FPMCustomPage",
    BuildingBlocks = "BuildingBlocks"
}
export declare enum ExportArtifacts {
    flex = "flex",
    manifest = "manifest"
}
export declare enum ALPViewType {
    Primary = "primary",
    Secondary = "secondary"
}
export declare enum SectionType {
    Section = "Section",
    SubSection = "SubSection",
    HeaderSection = "HeaderSection"
}
export declare enum ArtifactType {
    Manifest = "Manifest",
    FlexChange = "FlexChange",
    Annotation = "Annotation",
    XMLProperty = "XMLProperty"
}
export declare enum ActionType {
    Annotation = "Annotation",
    Copy = "Copy",
    Criticality = "Criticality",
    Custom = "Custom",
    RelatedApps = "RelatedApps",
    Standard = "Standard"
}
export declare enum ControlType {
    Table = "sap.m.Table",
    TableColumn = "sap.m.Column",
    SmartTable = "sap.ui.comp.smarttable.SmartTable",
    SmartFilterBar = "sap.ui.comp.smartfilterbar.SmartFilterBar",
    SmartChart = "sap.ui.comp.smartchart.SmartChart",
    Group = "sap.ui.comp.smartform.Group",
    GroupElement = "sap.ui.comp.smartform.GroupElement",
    Button = "sap.m.Button",
    ToolbarButton = "sap.m.OverflowToolbarButton",
    Avatar = "sap.f.Avatar",
    ObjectPageDynamicHeaderTitle = "sap.uxap.ObjectPageDynamicHeaderTitle",
    ObjectPageGridProperties = "sap.ui.layout.GridData",
    ObjectPageHeader = "sap.uxap.ObjectPageHeader",
    ObjectPageLayout = "sap.uxap.ObjectPageLayout",
    HeaderAction = "sap.uxap.ObjectPageHeaderActionButton",
    ObjectPageHeaderSection = "sap.m.VBox",
    DynamicPage = "sap.f.DynamicPage",
    Form = "sap.ui.layout.form",
    Chart = "sap.suite.ui.microchart",
    Section = "sap.uxap.ObjectPageSection",
    SubSection = "sap.uxap.ObjectPageSubSection"
}
export interface ChangeContent {
    property: string;
    newValue?: ManifestSettingsType;
    newBinding?: string | object;
}
export declare enum Visualization {
    LineItem = "LineItem",
    Chart = "Chart"
}
export declare enum DirName {
    Sapux = "src",
    Schemas = ".schemas",
    Pages = "pages",
    Webapp = "webapp",
    Temp = ".tmp",
    Changes = "changes",
    LocalService = "localService",
    Controller = "controller",
    View = "view",
    Fragment = "fragment",
    Ext = "ext",
    VSCode = ".vscode"
}
export declare enum FileName {
    App = "app.json"
}
export declare const FACETTITLEPREFIX = "Facet ID: ";
export declare const ACTIONTITLEPREFIX = "Action ID: ";
export declare enum ChangeIndicator {
    NoChange = "NoChange",
    Created = "Created",
    Updated = "Updated",
    Deleted = "Deleted"
}
export interface FileData {
    dataSourceUri: string;
    fileContent: string;
}
export interface FileDataResult extends FileData {
    changeIndicator: ChangeIndicator;
}
export interface ExportResults {
    manifest: Manifest;
    flexChanges?: string[];
    fragments?: FileDataResult[];
    views?: FileDataResult[];
    manifestChangeIndicator: ChangeIndicator;
}
export declare const defaultExportResult: ExportResults;
/**
 * Taken over from https://github.com/sap-staging/ui5-flexibility-utils/blob/origin/master/src/changeUtils.js
 */
export interface ChangeDefinition {
    controlId: string;
    controlType: string;
    type: string;
    content: ChangeContent;
    isCustomer: boolean;
    sapui5Version: string;
    creatingTool: string;
    id: string;
    reference: string;
    appVersion: string;
    creation: string;
}
/**
 * Taken over from https://github.com/sap-staging/ui5-flexibility-utils/blob/origin/master/src/changeUtils.js
 */
export interface ChangeDefinitionInCreation {
    controlId: string;
    controlType: string;
    type?: string;
    content: ChangeContent;
    isCustomer?: boolean;
    sapui5Version?: string;
    creatingTool?: string;
}
export type exportFlexValue = (flexChange: ChangeDefinitionInCreation, configObject: object, key: string) => void;
export type importFlexValue = (flexChange: ChangeDefinitionInCreation, configObject: object, key: string) => void;
export type ControlTypeFunction = () => ControlType;
export type ControlIdFunction = (baseId: string, idBreadcrumbs: string[], breadcrumbs: string[], controlType?: ControlTypeFunction, title?: string) => string;
export interface FlexAdapter {
    controlId?: ControlIdFunction;
    controlType: ControlTypeFunction;
    exportFlexValue?: exportFlexValue;
    importFlexValue?: importFlexValue;
}
export type ManifestPath = (pageKeys?: string[], manifest?: Manifest, ...pathParts: any[]) => string;
export type ExportHandlerFunction = (manifestSection: unknown, configObject: unknown, key: string, manifestKey?: string, ...pathParts: string[]) => unknown;
export interface ManifestConverter {
    path?: ManifestPath;
    key?: string;
    import?: ((manifestSection: unknown, sectionId?: string, propertyKey?: string, breadcrumbs?: string[]) => unknown) | boolean;
    export?: ExportHandlerFunction | boolean;
    delete?: ((manifestSection: unknown, configObject: unknown, key: string, manifestKey: string, syncRuleKey?: string, config?: object) => unknown) | boolean;
}
/**
 * Type describing the parameters being used by a step in the schema generation. Will be evaluated by the elementAdapters.
 *
 * @property pageInfo - generic information applicable to all levels of the type hierarchy. Prepared by getAdaptedSchema and unchanged afterwards.
 * @property pageInfo.appId - Information about the page the schema is generated for
 * @property pageInfo.componentName - the Fiori Elements template component for the page
 * @property pageInfo.entitySet - the entity set for the page
 * @property pageInfo.controlId - the id of the view FE runtime will generate for the page
 * @property pageInfo.pagePath - the page path to the page for which the schema is generated
 * @property specificParams - object that contains information specific for the current step of schema generation. elementAdapter adapts the content of this property if necessary for the next level.
 */
export type SchemaHandlingParams = {
    pageInfo: {
        appId: string;
        componentName: string;
        entitySet: string;
        controlId: string;
        pagePath: AccessorPath;
    };
    specificParams?: object;
};
/**
 * An instance of this type can process all properties of a record type.
 * For each property it has the same task as an instance of type ElementAdapter (see below) for one property
 * Instances of this type will be provided as values of referenceAdaptation.processingRuleProvider of the ProcessingRule valid for the record type (dynamic case)
 * If such a value does not exist (static case) an instance of this type will be created on the fly based on the elementAdapters in the syncRules of the properties of the record type.
 */
export type ProcessingRuleProvider = (property: string, element: Definition) => ProcessingRule | undefined;
/**
 * Instances of this type are the parameter-less constructors of classes which representing a section within the config for a FE v2 page.
 * The corresponding class should be annotated with a syncRule.
 * This syncRule must provide a elementAdapter determining the process of generating the corresponding section in the specific schema.
 */
export type SyncRuleProvider = {
    new (): object;
};
/**
 * Instances of this interface are used within type ProcessingRule. An instance provides information how to transform the next level of the generic schema to the page specific schema.
 *
 * @property suffix - If truthy, for referred types a copy with this suffix will be generated and the reference will be adapted accordingly. Needed if more than one instance of the referred type is required.
 * Example: The specific schema should contain a list of fields that depends on the entity set of the page. Each of these fields will have a type specific for this field.
 * In this case the generic schema will only contain one generic type 'Field' serving as a blueprint for the specific types.
 * When generating the specific schema a specific copy of this type will be created for each field. The name of this type could e.g. be build according to the pattern `Field<${fieldname}>`.
 * In this case fieldname should be used as suffix to trigger this behavior.
 * @property specificParams - If truthy this replaces the content of property specificParams of the SchemaHandlingParams-instance passed to the next level
 * @property syncRuleProvider - provides the syncRule for the next level
 * @property refTypeDefinition - is needed if the currently processed schema section refers to a type which is not contained in the static schema. In this case the property contains the definition of this new type.
 */
export interface AdaptationInfo {
    suffix?: string;
    specificParams?: object;
    syncRuleProvider?: SyncRuleProvider;
    refTypeDefinition?: Definition;
}
/**
 * An instance of this interface describes the way the properties of the currently processed schema section should be processed.
 *
 * @property processingRuleProvider - only needed when the list of properties is determined dynamically. In this case the list of properties
 * must be added to the schema section by the elementAdapter.
 */
export interface ReferenceAdaptationInfo extends AdaptationInfo {
    processingRuleProvider?: ProcessingRuleProvider;
}
/**
 * A path of accessors (property names resp. array indices) which can be used to navigate to a child object inside a javascript object. The length of the path corresponds to the sub-object level.
 * In the context of this project instances of this class are used for two purposes:
 * a) Describe a 'manifest path' (i.e. a path from manifest root to an property or a section within the manifest)
 * b) Describe a 'page path' (i.e. a path under the sap.ui.generic.app-element of the manifest of a FE v2 app)
 * In case b) every second accessor element has fixed name 'pages'. This fixed string will be left out in page paths (but not in manifest paths containing it).
 * Function getManifestPathFromPagePath in file v2.utils.ts can be used to build a manifest path out of a page path
 */
export type AccessorPath = (string | number)[];
/**
 * An instance of this type specifies how to access one or a number of sub-objects inside a javascript object.
 *
 * @property addTargetPropertyToPath - if true the given path only specifies the parent object of the target object.
 * In this case it is assumed that there is another property name known from the context which can be used to do the last step.
 * If addTargetPropertyToPath is false this additional assumption is not true and a context (even if it is there) will be ignored.
 * This is used in case the sub-object to be found does not have the same accessor as defined by the context.
 * The first option (addTargetPropertyToPath = true) is considered to be the default option. Therefore, it is possible to directly use the AccessorPath.
 * @property path - the path to the parent object of the target resp. to the target object itself, depending on addTargetPropertyToPath
 */
export type AccessorSpec = AccessorPath | {
    addTargetPropertyToPath: boolean;
    path: AccessorPath;
};
/**
 * An instance of this type provides information how a section of the specific schema will be adapted.
 * Instances of this type are provided either by property elementAdapter of a syncRule (static case) or by an instance of type ProcessingRuleProvider (dynamic case).
 *
 * @property controlId - should be truthy for properties which are realized by flex changes. Provides the id of the control the flex change applies to. Will be added to the schema then.
 * @property manifestPath - should be truthy for properties which are realized in the manifest. Specifies the corresponding place in the manifest. Will be added to the schema then.
 * @property referenceAdaptation - Information how the link to the next hierarchy level should be processed
 * @property additionalPropertiesAdaptation - Information how the additionalProperties section should be processed
 * @property itemsAdaptation - Information how the items section should be processed
 */
export type ProcessingRule = {
    controlId?: string;
    manifestPath?: AccessorSpec;
    referenceAdaptation?: ReferenceAdaptationInfo;
    additionalPropertiesAdaptation?: AdaptationInfo;
    itemsAdaptation?: AdaptationInfo;
};
/**
 * An instance of this type determines the way a certain section from the generic schema will be processed when translating it to the specific schema.
 *
 * @param element - a defensive copy of the section currently processed. The task of this function is:
 * a) to decide whether the section should be part of the resulting schema at all
 * if the answer to a) is 'yes':
 * b) possibly adapt it. This may even include dynamically adding a 'properties' or an 'items' section to it. These sections will be processed
 *    as if they had been part of the generic schema from the beginning.
 * c) possibly provide information that can be added to the section generically (e.g. a manifest path)
 * d) provide information how to process the next hierarchy level
 * @param schemaHandlingParams - information provided by the hierarchy level above
 * @param generateParameters - input parameters for the schema generation process
 * @returns undefined if the answer to a) is 'no', otherwise the ProcessingRule that determines c) and d) of the list above. In particular
 * the return of an empty ProcessingRule indicates that element should be taken over to the specific schema unmodified.
 */
type ElementAdapter = (element: Definition, schemaHandlingParams: SchemaHandlingParams, generateParameters: GenerateAppSchemaParameters) => ProcessingRule | undefined;
/**
 * Use function syncRule in class specification/src/sync/common/decoration/decorators to annotate classes and properties built for schema generation.
 * This way the generation of generic and specific schemas is controlled by the syncRules.
 *
 * @property flex
 * @property manifest
 * @property elementAdapter - this property is used when the specific schema is created via getAdaptedSchema
 * @property generate
 * @property xml
 */
export interface SyncRule {
    flex?: FlexAdapter;
    manifest?: ManifestConverter;
    elementAdapter?: ElementAdapter;
    generate?: (schema: object, definition: object, propertyName: string) => unknown;
    xml?: (config: any) => string;
}
export interface Content {
    property: string;
    oldValue?: ManifestSettingsType;
    newValue: ManifestSettingsType;
}
export interface Selector {
    id: string;
    type: string;
    idIsLocal?: boolean;
}
export interface PageLayoutInformation {
    id: string;
    pageId: string;
}
export interface FakeLRepSettings {
    isKeyUser: boolean;
    isAtoAvailable: boolean;
    isProductiveSystem: boolean;
}
export interface ValidityInformation {
    since: string;
    deprecated?: Deprecated;
}
export interface DeprecatedProperties {
    [key: string]: ValidityInformation;
}
export interface Deprecated {
    since: string;
    text?: string;
}
export declare enum FacetBase {
    LineItem = "LineItem",
    CollectionFacet = "CollectionFacet",
    Chart = "Chart",
    Form = "Form",
    Identification = "Identification",
    DataPoint = "DataPoint",
    Address = "Address",
    Contact = "Contact",
    PresentationVariant = "PresentationVariant",
    SelectionPresentationVariant = "SelectionPresentationVariant",
    Unknown = ""
}
export interface FacetConfig {
    base: FacetBase;
    lineItem?: string[];
    Label?: string;
    ID?: string;
    entityType?: EntityType;
    annotationPath?: string;
    target?: object;
    Title?: string;
    facets?: FacetConfigs;
    namespace?: string;
}
export interface SubSectionConfig {
    base: FacetBase;
    Label?: string;
    ID?: string;
    facets: FacetConfigs;
    annotationPath?: string;
    entityType?: EntityType;
    target?: object;
    namespace?: string;
}
export interface FacetConfigs {
    [key: string]: FacetConfig | SubSectionConfig;
}
export interface File {
    dataSourceUri: string;
    fileContent: string;
}
export interface Files {
    [name: string]: object;
}
export interface FacetSection {
    key: string;
    label?: string;
    ID?: string;
    custom?: boolean;
    entityType?: EntityType;
    namespace?: string;
    title?: string;
}
export interface SchemaFilePath {
    filename: string;
    path: string;
}
export interface ObjectPageSectionData {
    target: string;
    key?: string;
}
export declare const BINDINGPROPERTYREGEXSTRING = "^{[A-Za-z0-9{}&$!@#%? _|,<>'()[\\]\\/:=.]+}$";
export declare enum ViewTemplateType {
    ResponsiveTableColumnsExtension = "ResponsiveTableColumnsExtension",
    AnalyticalTableColumnsExtension = "AnalyticalTableColumnsExtension",
    TreeTableColumnsExtension = "TreeTableColumnsExtension",
    GridTableColumnsExtension = "GridTableColumnsExtension",
    ResponsiveTableCellsExtension = "ResponsiveTableCellsExtension"
}
export declare enum DefinitionName {
    Action = "Action",
    Actions = "Actions",
    ActionsLR = "Actions<LineItems>",
    ALPChart = "ALPChart",
    ALPChartView = "ALPChartView",
    ALPTable = "ALPTable",
    ALPTableView = "ALPTableView",
    AnalyticalListPageFilterBar = "AnalyticalListPageFilterBar",
    AnnotationPathAsObject = "AnnotationPathAsObject",
    ChartSettings = "ChartSettings",
    ChartToolBarAction = "ChartToolBarAction",
    CommonHeaderFacetSettings = "CommonHeaderFacetSettings",
    CompactFilters = "CompactFilters",
    CustomFooterActionOP = "CustomFooterActionOP",
    CustomHeaderAction = "CustomHeaderAction",
    CustomHeaderActionOP = "CustomHeaderActionOP",
    CustomFormActionOP = "CustomFormActionOP",
    CustomTableAction = "CustomTableAction",
    CustomTableActionOP = "CustomTableActionOP",
    CustomColumn = "TableCustomColumn",
    CustomColumnOP = "TableCustomColumnOP",
    CustomColumns = "TableCustomColumns",
    CustomSections = "CustomSections",
    FieldPath = "FieldPath",
    Field = "Field",
    Fields = "Fields",
    Fields4Dialog = "Fields4Dialog",
    FilterBar = "FilterBar",
    FilterBarVisualFilters = "FilterBarVisualFilters",
    Footer = "Footer",
    FooterAction = "FooterAction",
    FooterActionV4 = "FooterActionV4",
    FooterActions = "FooterActions",
    FooterActionsLR = "FooterActions<LineItems>",
    Form = "Form",
    FormAction = "FormAction",
    GenericActions = "GenericActions",
    GenericColumnsOP = "GenericColumnsOP",
    GenericFooter = "GenericFooter",
    GenericSections = "GenericSections",
    GenericSubSections = "GenericSubSections",
    GlobalTableSettings = "GlobalTableSettings",
    Header = "Header",
    HeaderActions = "HeaderActions",
    HeaderActionsStandard = "HeaderActionsStandard",
    HeaderActionStandard = "HeaderActionStandard",
    ObjectPageHeaderAction = "ObjectPageHeaderAction",
    ObjectPageHeaderActionStandard = "ObjectPageHeaderActionStandard",
    ObjectPageHeaderActions = "ObjectPageHeaderActions",
    HeaderSections = "HeaderSections",
    LineItems = "LineItems",
    LineItemsOfView = "LineItemsOfView",
    ListReportFilterBar = "ListReportFilterBar",
    LRTableView = "LRTableView",
    LRChartView = "LRChartView",
    MultiEditV2 = "MultiEdit",
    MultiTableModeV4 = "MultiTableModeV4",
    ObjectPageChart = "ObjectPageChart",
    ObjectPageCustomHeaderSectionFragment = "ObjectPageCustomHeaderSectionFragment",
    ObjectPageCustomSectionFragment = "ObjectPageCustomSectionFragment",
    ObjectPageCustomSubSectionFragment = "ObjectPageCustomSubSectionFragment",
    ObjectPageForm = "ObjectPageForm",
    ObjectPageFooter = "ObjectPageFooter",
    ObjectPageFooterAction = "ObjectPageFooterAction",
    ObjectPageFooterActions = "ObjectPageFooterActions",
    ObjectPageFooterActionStandard = "ObjectPageFooterActionStandard",
    ObjectPageHeader = "ObjectPageHeader",
    ObjectPageHeaderSectionForm = "ObjectPageHeaderSectionForm",
    ObjectPageHeaderSectionChart = "ObjectPageHeaderSectionChart",
    ObjectPageHeaderSectionDataPoint = "ObjectPageHeaderSectionDataPoint",
    ObjectPageHeaderSectionContact = "ObjectPageHeaderSectionContact",
    ObjectPageHeaderSectionAddress = "ObjectPageHeaderSectionAddress",
    ObjectPageLayout = "ObjectPageLayout",
    ObjectPagePresentationVariant = "ObjectPagePresentationVariant",
    ObjectPageSectionAddress = "ObjectPageSectionAddress",
    ObjectPageSectionChart = "ObjectPageSectionChart",
    ObjectPageSectionContact = "ObjectPageSectionContact",
    ObjectPageSectionDataPoint = "ObjectPageSectionDataPoint",
    ObjectPageSectionForm = "ObjectPageSectionForm",
    ObjectPageSectionPresentationVariant = "ObjectPageSectionPresentationVariant",
    ObjectPageSectionTableV4 = "ObjectPageSectionTableV4",
    ObjectPageSubSections = "ObjectPageSubSections",
    ObjectPageResponsiveTableV4 = "ObjectPageResponsiveTableV4",
    ObjectPageAnalyticalTableV4 = "ObjectPageAnalyticalTableV4",
    ObjectPageGridTableV4 = "ObjectPageGridTableV4",
    ObjectPageTreeTableV4 = "ObjectPageTreeTableV4",
    ObjectPageTable = "ObjectPageTable",
    ObjectPageTableColumn = "ObjectPageTableColumn",
    ObjectPageToolBar = "ObjectPageToolBar",
    ObjectPageToolBarAction = "ObjectPageToolBarAction",
    ObjectPageToolBarActions = "ObjectPageToolBarActions",
    Position = "Position",
    PositionOP = "PositionOP",
    QuickVariant = "QuickVariant",
    QuickVariantSelectionOP = "QuickVariantSelectionOP",
    QuickVariantSelectionV4OP = "QuickVariantSelectionV4OP",
    RelatedFacetKeys = "RelatedFacetKeys",
    Sections = "Sections",
    SectionActions = "SectionActions",
    SelectionFields = "SelectionFields",
    Table = "Table",
    TableSPV = "TableSPV",
    TableColumn = "TableColumn",
    TableViewExtension = "TableViewExtension",
    ToolBarAction = "ToolBarAction",
    ToolBarLR = "ToolBar<LineItems>",
    ToolBar = "ToolBar",
    ViewTableColumn = "ViewTableColumn",
    ViewCustomColumn = "ViewTableCustomColumn",
    ViewCustomAction = "ViewTableCustomAction",
    ViewChartToolBar = "ViewChartToolBar",
    ViewToolBarAction = "ViewToolBarAction",
    ViewPosition = "ViewPosition",
    ViewCustomActionPosition = "ViewCustomActionPosition",
    VisualFilters = "VisualFilters",
    VisualFilter = "VisualFilter",
    CustomActionPosition = "CustomActionPosition",
    CustomActionPositionOP = "CustomActionPositionOP",
    CustomHeaderActionPosition = "CustomHeaderActionPosition",
    CustomHeaderActionPositionOP = "CustomHeaderActionPositionOP",
    CustomFooterActionPositionOP = "CustomFooterActionPositionOP",
    CustomExtensionFragment = "CustomExtensionFragment",
    CustomFilterField = "CustomFilterField",
    CustomFilterFieldPosition = "CustomFilterFieldPosition",
    SaveAndEdit = "SaveAndEdit",
    ObjectPageCustomSectionActions = "ObjectPageCustomSectionActions",
    CustomSectionActionOP = "CustomSectionActionOP",
    CustomSectionActionPositionOP = "CustomSectionActionPositionOP"
}
export declare enum PropertyName {
    actions = "actions",
    annotationPath = "annotationPath",
    chart = "chart",
    columns = "columns",
    defaultPath = "defaultPath",
    defaultTemplateAnnotationPath = "defaultTemplateAnnotationPath",
    footer = "footer",
    header = "header",
    sections = "sections",
    table = "table",
    views = "views",
    visualFilters = "visualFilters",
    selectionFields = "selectionFields"
}
/**
 * Additional tags for json schema used in specification. The explanations below specify the meaning of the values for these tags in the schema.
 *
 * @property actionType - type of an action, possible values from enum ActionType
 * @property annotationPath - path to annotation
 * @property annotationType - type, as defined in the annotation
 * @property artifactType - type of the artifact, possible values from enum ArtifactType
 * @property controlId - id of the UI5 control, for flex changes
 * @property controlType - type of the UI5 control, for flex changes
 * @property conversionExit - not used yet
 * @property dataType - EDM data type
 * @property deletable - indicates whether it is allowed to delete a view node (default: false)
 * @property descriptionSrcURL - URL to the description of the artifact in sap.help.com
 * @property fullyQualifiedName
 * @property hidden - flag to indicate if the artifact shall be hidden in the UI
 * @property icon - the icon to be displayed for the artifact. Must be a member of enum UiIcons from @sap-ux/ui-components.
 * @property isViewNode - flag to indicate if the artifact is a view node in the outline
 * @property key - main key of the artifact
 * @property keys - all key elements of the artifact
 * @property manifestPath - an object of type AccessorSpec describing how the setting for the artifact can be identified in the manifest
 * @property messages - an array of messages associated to the current definition
 * @property propertyIndex - index of the property, in any collection
 * @property target - namespace of an annotation
 */
export declare enum SchemaTag {
    actionType = "actionType",
    annotationPath = "annotationPath",
    annotationType = "annotationType",
    artifactType = "artifactType",
    controlId = "controlId",
    controlType = "controlType",
    conversionExit = "conversionExit",
    dataType = "dataType",
    deletable = "deletable",
    descriptionSrcURL = "descriptionSrcURL",
    fullyQualifiedName = "fullyQualifiedName",
    hidden = "hidden",
    icon = "icon",
    isViewNode = "isViewNode",
    key = "key",
    keys = "keys",
    manifestPath = "manifestPath",
    messages = "messages",
    propertyIndex = "propertyIndex",
    target = "target"
}
export declare enum SchemaKeyName {
    id = "ID",
    value = "Value",
    action = "Action",
    target = "Target",
    key = "Key",
    semanticObject = "SemanticObject"
}
export declare const MANIFESTPATH = "webapp/manifest.json";
export declare const VOCWITHSLASH = "/@com.sap.vocabularies";
export declare const VOCWITHCOLONS = "::@com.sap.vocabularies";
export declare const UIVOCABULARY = "com.sap.vocabularies.UI.v1";
export declare const UIVOCABULARYDOT = "com.sap.vocabularies.UI.v1.";
export declare const UIVOCABULARYALPHADOT = "@com.sap.vocabularies.UI.v1.";
export declare const QUICKVARPATH = "/quickVariantSelection";
export declare const QUICKVARPATHX = "/quickVariantSelectionX";
export declare const DATESETTINGSPATH = "/filterSettings/dateSettings";
export declare const FRAGMENTNAMEPART = ".fragment.";
export interface MacrosXMLPathInfo {
    name: string;
    index: number;
}
export type MacrosXMLPath = Array<MacrosXMLPathInfo>;
export declare enum MacrosPropertyType {
    Control = "Control",
    Property = "Property",
    Aggregation = "Aggregation",
    Event = "Event"
}
export interface SelectionPositionRange {
    startOffset: number;
    endOffset: number;
    startLine: number;
    endLine: number;
    startColumn: number;
    endColumn: number;
}
export interface MacrosSchemaMetadata {
    path?: MacrosXMLPath;
    controlName?: string;
    type?: MacrosPropertyType;
    position?: SelectionPositionRange;
    filePath?: string;
    internalId?: string;
    defaultAggregation?: string;
    namespaces?: string[];
}
export interface SchemaDefinitionKey {
    name: SchemaKeyName;
    value: string;
}
export interface SchemaDefinition extends Definition {
    isViewNode?: boolean;
    propertyIndex?: number;
    metadata?: MacrosSchemaMetadata;
    hidden?: boolean;
    annotationPath?: string;
    keys?: SchemaDefinitionKey[];
}
export {};
//# sourceMappingURL=types.d.ts.map